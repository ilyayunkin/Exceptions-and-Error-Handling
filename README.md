[Оригинал](https://isocpp.org/wiki/faq/exceptions#why-exceptions)

# Зачем нужны исключения?

*Что исключения дают мне?* Общий ответ: Использование исключений при обработке ошибок делает ваш код проще, чище, надежнее. 
*Что не так со старым добрым errno и if-else?* Общий ответ: Они порождают переплетение обычного кода и кода обработки ошибок. Так ваш код становится беспорядочным истановится сложно понять, все ли ошибки вы обрабатываете ("спагетти-код", "крысиное гнездо проверок").

МНогие вещи просто невозможны без исключений. Представьте, что ошибка обнаружена в конструкторе - как вы о ней сообщите? Придется бросить исключение. Это основа идиомы RAII (Выделение ресурсов есть инициализация), которая сама является основой наиболее эффективных современных техник. Задача конструктора - гарантировать инвариант класса (создать среду, в которой функции-члены работают), что обычно требует выделения ресурсов (памяти, блокировок, файлов, сокетов, ...).

Imagine that we did not have exceptions, how would you deal with an error detected in a constructor? Remember that constructors are often invoked to initialize/construct objects in variables:

Как бы мы обрабатывали ошибки, возникающие в конструкторе, не будь у нас исключений? 
```
    vector<double> v(100000);   // needs to allocate memory
    ofstream os("myfile");      // needs to open a file
```
Конструкторы классов vector или ofstream (output file stream) могли бы установить объекты в некое "плохое состояние" (ifstream так и делает по-умолчанию). Тогда бы все последующие операции были неудачны, что далеко от идеала. В случае с ofstream весь ваш вывод просто исчезает, если вы забыли проверить успешность инициализации. Для большинства классов последствия еще хуже. Как минимум, нам бы пришлось написать это:
```
    vector<double> v(100000);   // needs to allocate memory
    if (v.bad()) { /* handle error */ } // vector doesn't actually have a bad(); it relies on exceptions
    ofstream os("myfile");      // needs to open a file
    if (os.bad())  { /* handle error */ }
```

Видите эти дополнительные тесты на каждый объект? Полный бардак наступает при использовании классов, содержащих в себе несколько объектов, особенно если эти объеты взаимозависимы. Подробнее читайте в параграфе 8.3  и приложении 14 "C++ Programming Language" или в более научной статье [Exception safety: Concepts and techniques](http://stroustrup.com/except.pdf).

So writing constructors can be tricky without exceptions, but what about plain old functions? We can either return an error code or set a non-local variable (e.g., errno). Setting a global variable doesn’t work too well unless you test it immediately (or some other function might have re-set it). Don’t even think of that technique if you might have multiple threads accessing the global variable. The trouble with return values are that choosing the error return value can require cleverness and can be impossible:

Итак, написание конструкторов может быть непростым без исключений. А что с простыми функциями, Мы могли бы вернуть код ошибки или установить нелокальную переменную (errno, например). Передача значения через глобальную переменную не работает хорошо, сли вы не проверяете ее сразу же. Даже не думайте о таком пути, если у вас больше одного потока. Возврат ошибок через возвращаемое значение может потребовать смекалки и быть вообще невозможным:
```
    double d = my_sqrt(-1);     // return -1 in case of error
    if (d == -1) { /* handle error */ }
    int x = my_negate(INT_MIN); // Duh?
```
Любой int является корректным значением для некоего входного значения функции my_negate(). В таких случаях нам потребуется возвращать пару значений и не забывать про проверки. (See Stroustrup’s Beginning programming book)

Типичные возражения против исключений:
* "Исключения накладны". Не слишком. Современные реализации С++ сокращают накладные расходы до нескольких процентов (пусть будет 3%) в сравнении с игнорированием ошибок. Возврат кодов ошибок и их проверка тоже не бесплатны. А если вы не бросаете исключений, они совсемакладны или даже бесплатны. "Обычный" код будет работать даже быстрее,так как все расходы идут на создание исключения.
* "В JSF++ Страуструп прямо запрещает исключения". JSF++ написан для жеткого реального времени и safety-critical приложений управления полетом. Если вычисления занимают продолжительное время -кто-то может погибнуть, поэтому нам приходится гарантировать премя исполнения, но на текущем уровне назвития мы не можем дать гарантий для исключений. В данном случае запрещено даже распределение свободной памяти. Вообще говоря, рекомендации JSF++ симулируют работу исключений в ожидании дня, когда инструменты будут позволять дать больше гарантий при использовании исключений.
* "Использование конструктора, вызванного операцией new, вызывает утечку памяти". Брехня! Это бабьи басни, вызванные ошибкой в одном из компиляторов, исправленной десятилетие назад.

