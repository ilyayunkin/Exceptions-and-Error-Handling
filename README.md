[Оригинал](https://isocpp.org/wiki/faq/exceptions#why-exceptions)

### Зачем нужны исключения?

**Что исключения дают мне?** Общий ответ: Использование исключений при обработке ошибок делает ваш код проще, чище, надежнее. 
**Что не так со старым добрым errno и if-else?** Общий ответ: Они порождают переплетение обычного кода и кода обработки ошибок. Так ваш код становится беспорядочным истановится сложно понять, все ли ошибки вы обрабатываете ("спагетти-код", "крысиное гнездо проверок").

МНогие вещи просто невозможны без исключений. Представьте, что ошибка обнаружена в конструкторе - как вы о ней сообщите? Придется бросить исключение. Это основа идиомы RAII (Выделение ресурсов есть инициализация), которая сама является основой наиболее эффективных современных техник. Задача конструктора - гарантировать инвариант класса (создать среду, в которой функции-члены работают), что обычно требует выделения ресурсов (памяти, блокировок, файлов, сокетов, ...).

Imagine that we did not have exceptions, how would you deal with an error detected in a constructor? Remember that constructors are often invoked to initialize/construct objects in variables:

Как бы мы обрабатывали ошибки, возникающие в конструкторе, не будь у нас исключений? 
```
    vector<double> v(100000);   // needs to allocate memory
    ofstream os("myfile");      // needs to open a file
```
Конструкторы классов vector или ofstream (output file stream) могли бы установить объекты в некое "плохое состояние" (ifstream так и делает по-умолчанию). Тогда бы все последующие операции были неудачны, что далеко от идеала. В случае с ofstream весь ваш вывод просто исчезает, если вы забыли проверить успешность инициализации. Для большинства классов последствия еще хуже. Как минимум, нам бы пришлось написать это:
```
    vector<double> v(100000);   // needs to allocate memory
    if (v.bad()) { /* handle error */ } // vector doesn't actually have a bad(); it relies on exceptions
    ofstream os("myfile");      // needs to open a file
    if (os.bad())  { /* handle error */ }
```

Видите эти дополнительные тесты на каждый объект? Полный бардак наступает при использовании классов, содержащих в себе несколько объектов, особенно если эти объеты взаимозависимы. Подробнее читайте в параграфе 8.3, главе 14  и приложении Е книги "C++ Programming Language" или в более научной статье [Exception safety: Concepts and techniques](http://stroustrup.com/except.pdf).

So writing constructors can be tricky without exceptions, but what about plain old functions? We can either return an error code or set a non-local variable (e.g., errno). Setting a global variable doesn’t work too well unless you test it immediately (or some other function might have re-set it). Don’t even think of that technique if you might have multiple threads accessing the global variable. The trouble with return values are that choosing the error return value can require cleverness and can be impossible:

Итак, написание конструкторов может быть непростым без исключений. А что с простыми функциями, Мы могли бы вернуть код ошибки или установить нелокальную переменную (errno, например). Передача значения через глобальную переменную не работает хорошо, сли вы не проверяете ее сразу же. Даже не думайте о таком пути, если у вас больше одного потока. Возврат ошибок через возвращаемое значение может потребовать смекалки и быть вообще невозможным:
```
    double d = my_sqrt(-1);     // return -1 in case of error
    if (d == -1) { /* handle error */ }
    int x = my_negate(INT_MIN); // Duh?
```
Любой int является корректным значением для некоего входного значения функции my_negate(). В таких случаях нам потребуется возвращать пару значений и не забывать про проверки. (See Stroustrup’s Beginning programming book)

Типичные возражения против исключений:
* "Исключения накладны". Не слишком. Современные реализации С++ сокращают накладные расходы до нескольких процентов (пусть будет 3%) в сравнении с игнорированием ошибок. Возврат кодов ошибок и их проверка тоже не бесплатны. А если вы не бросаете исключений, они совсемакладны или даже бесплатны. "Обычный" код будет работать даже быстрее,так как все расходы идут на создание исключения.
* "В JSF++ Страуструп прямо запрещает исключения". JSF++ написан для жеткого реального времени и safety-critical приложений управления полетом. Если вычисления занимают продолжительное время -кто-то может погибнуть, поэтому нам приходится гарантировать премя исполнения, но на текущем уровне назвития мы не можем дать гарантий для исключений. В данном случае запрещено даже распределение свободной памяти. Вообще говоря, рекомендации JSF++ симулируют работу исключений в ожидании дня, когда инструменты будут позволять дать больше гарантий при использовании исключений.
* "Использование конструктора, вызванного операцией new, вызывает утечку памяти". Брехня! Это бабьи басни, вызванные ошибкой в одном из компиляторов, исправленной десятилетие назад.

### Как использовать исключения?
Подробнее читайте в параграфе 8.3, главе 14  и приложении Е книги "C++ Programming Language". Приложение написано не для новичков.

В С++ исключения используются для оповещения об ошибках, которые нельзя обработать в месте их возникновения, например ошибка выделения ресурсов, запрошеных в конструкторе:
```
    class VectorInSpecialMemory {
        int sz;
        int* elem;
    public:
        VectorInSpecialMemory(int s) 
            : sz(s) 
            , elem(AllocateInSpecialMemory(s))
        { 
            if (elem == nullptr)
                throw std::bad_alloc();
        }
        ...
    };
```

Do not use exceptions as simply another way to return a value from a function. Most users assume – as the language definition encourages them to – that ** exception-handling code is error-handling code **, and implementations are optimized to reflect that assumption.

Не пользуйтесь исключениями просто для возврата значения из функции. Исключения предназначены для обработки ошибок и реализации оптимизированы в этом направлении.

Ключевая техника - RAII (resource acquisition is initialization), использующая конструкторы и деструкторы чтобы упорядочить управление ресурсами:
```
  void fct(string s)
    {
        File_handle f(s,"r");   // File_handle's constructor opens the file called "s"
        // use f
    } // here File_handle's destructor closes the file  
```
Если при использовании f бросаются исключения, деструктор будет вызван и файл будет должным образом закрыт, в отличие от типового стандартного решения:
```
    void old_fct(const char* s)
    {
        FILE* f = fopen(s,"r"); // open the file named "s"
        // use f
        fclose(f);  // close the file
    }
```    
Если при использовании f бросаются исключения или просто встречается return, файл не будет закрыт. В программах на языке Си longjmp() является дополнительной угрозой.

### Как не стоит использовать исключения?
C++ exceptions are designed to support error handling.

Use throw only to signal an error (which means specifically that the function couldn’t do what it advertised, and establish its postconditions).
Use catch only to specify error handling actions when you know you can handle an error (possibly by translating it to another type and rethrowing an exception of that type, such as catching a bad_alloc and rethrowing a no_space_for_file_buffers).
Do not use throw to indicate a coding error in usage of a function. Use assert or other mechanism to either send the process into a debugger or to crash the process and collect the crash dump for the developer to debug.
Do not use throw if you discover unexpected violation of an invariant of your component, use assert or other mechanism to terminate the program. Throwing an exception will not cure memory corruption and may lead to further corruption of important user data.

Исключения в С++ созданы для *обработки ошибок*.
*Используйте **throw** только чтобы сообщить о возникновении ошибки, когда функция не может выполнить то, что она обещает и выполнить ее постусловия.
*Используйте **catch** только когда вы знаете, что можете обработать ошибку (иногда переводом ошибки в другой тип и бросанием исключения нового типа - например, поймав bad_alloc, можно бросить no_space_for_file_buffers).
*Не используйте **throw** для оповещения об ошибках использования - используйте **assert** или иные средства, чтобы отправить процесс в отладчик, или дайте процессу упасть, чтобы получить **crash dump** для отладки.
*Не используйте  **throw** при обнаружении неожиданного нарушения инварианта в вашем компоненте - используйте **assert** или иные средства, чтобы завершить программу. Бросание исключения не излечит порчу памяти и может повлечь дальнейшую порчу пользовательских данных.

There are other uses of exceptions – popular in other languages – but not idiomatic in C++ and deliberately not supported well by C++ implementations (those implementations are optimized based on the assumption that exceptions are used for error handling).

In particular, do not use exceptions for control flow. throw is not simply an alternative way of returning a value from a function (similar to return). Doing so will be slow and will confuse most C++ programmers who are rightly used to seeing exceptions used only for error handling. Similarly, throw is not a good way of getting out of a loop.

Есть иные приложения исключений, используемые в других языках, но нестандартные для С++ и не поддерживаемые в полной мере в реазизациях  С++.

В частности, не используйте исключения для описания логики. Оператор **throw** - не посто иной способ вернуть значение из функции. Это сделает вашу программу медленной и смутит большинство С++ программистов, которые используют исключения только для обработки ошибок. Так же **throw** - плохой способ выйти из цикла.

### Как try / catch / throw могут улучшить качество ПО?  
Устранением одной из причин для условного перехода.

Широко используемая альтернатива исключениям - возврат кода ошибки, который должен быть явно проверен неким условным оператором, например, if. Например, printf(), scanf() and malloc() работают так: вызывающий должен проверить возвращенное значение, чтобы убедиться, что функция успешно отработала.

Хотя возврат кодов ощибок **иногда** есть наиболее правильный способ обработки ошибок, есть побочные эффекты от ввода дополнительных условных операторов:
* Снижение качества: хорошо известно, что условные операторы примерно в 10 раз чаще содержат ошибки, чтем какие-либо иные операторы. То есть, при прочих равных условиях, избегая дополнительных  условных переходов, вы получаете более надежный код.
* Замедление выхода на рынок: так как условные операторы являются точками ветвления, влияющими на число тестовых случаев, необходимых для тестирования белого ящика, необязательные условные переходы увеличивают продолжительность тестирования. Обычно если вы не испытываете все точки ветвления, в вашем коде останутся инструкции, которые ни разу не вызывались, пока они не попадут к заказчику / потребителю. 
* Возрастание цены разработки: поиск ошибок, исправление ошибок, тестирование требуют все больше времени с усложнением логики.

Так что, в сравнениие с оповещением об ошибках через возвращаемые значения и if, использование try / catch / throw скорее помогут создать код с меньшим числом дефектов, меньшей стоимостью разработки, более скорым выходом на рынок. Конечно, если в вашей организации нет опыта использования try / catch / throw, будет полещно использовать из сначала на опытном проекте, чтобы понять, что вы знаете, что вы делаете - всегда нужно привыкнуть к орудию до его практического применения.

### Я все еще не убежден: фрагмент кода в 4 строки показывает, что что коды ошибок ничем не хуже исключений. Почему я должен использовать исключения на более крупных проектах?
Потому что исключения лучше масштабируются, чтом коды ошибок. Вот классический пример в 4 строки:
```
try {
  f();
  // ...
} catch (std::exception& e) {
  // ...code that handles the error...
}
```
Вот то же самое,  но с оповещением об ошибках через возвращаемое значение:
```
int rc = f();
if (rc == 0) {
  // ...
} else {
  // ...code that handles the error...
}
```
Люди показывают на эти крошечные примеры и говорят "Исключения не улучшают здесь ни кодирование, ни тестирование, ни стоимость поддержки. Почему я должен брать из в реальный проект?"

Причина: исключения помогают вам в риальных приложениях. Вы, вероятно, не увидите каких-либо выгод на крошечном примере.

В реальной жизнии, код который обнаруживает ошибку обычно должен передать ошибку назад в другую функцию, которая обработает проблему. Эта передачас ошибки часто требует прохода через десятки функций — f1() вызывает f2() вызывает f3(), etc. И проблема обнаруживается в f10() или f100(). Информация об ошибке должна быть передана назад, в f1(), потому что только f() обладает контекстом, чтобы понять, что нужно сделать в такой ситуации. В интерактивной программе f1() обычно близка к main event loop, но в любом случает код, который обнаруживает проблему - обычно не тот же код, который обрабатывает проблему, и информация об ошибке должна быть передана через всю цепочку вызовов.

Исключения делают передачу ошибки проще:
```
void f1()
{
  try {
    // ...
    f2();
    // ...
  } catch (some_exception& e) {
    // ...code that handles the error...
  }
}
void f2() { ...; f3(); ...; }
void f3() { ...; f4(); ...; }
void f4() { ...; f5(); ...; }
void f5() { ...; f6(); ...; }
void f6() { ...; f7(); ...; }
void f7() { ...; f8(); ...; }
void f8() { ...; f9(); ...; }
void f9() { ...; f10(); ...; }
void f10()
{
  // ...
  if ( /*...some error condition...*/ )
    throw some_exception();
  // ...
```
